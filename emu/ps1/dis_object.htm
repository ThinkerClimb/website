<!--
 ____________________________________________________________
|                                                            |
|    DESIGN + Pat Heard { http://fullahead.org }             |
|      DATE + 2006.09.12                                     |
| COPYRIGHT + Free use if this notice is kept in place.      |
|____________________________________________________________|

-->

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>司徒的教學網站</title>
  <meta http-lowast="content-type" content="application/xhtml+xml; charset=UTF-8" />
  <meta name="author" content="fullahead.org" />
  <meta name="keywords" content="XHTML, CSS, template, FullAhead" />
  <meta name="description" content="A valid, XHTML 1.0 template" />
  <meta name="robots" content="index, follow, noarchive" />
  <meta name="googlebot" content="noarchive" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes, minimum-scale=0.1, maximum-scale=100.0"/>

  <link rel="shortcut icon" href="../../website.ico">
  <link rel="stylesheet" type="text/css" href="../../styles/shCore.css" />
  <link rel="stylesheet" type="text/css" href="../../styles/shThemeDefault.css" />
  <link rel="stylesheet" type="text/css" href="../../css/html.css" media="screen, projection, tv " />
  <link rel="stylesheet" type="text/css" href="../../css/layout.css" media="screen, projection, tv" />
  <link rel="stylesheet" type="text/css" href="../../css/print.css" media="print" />
  
  <script type="text/javascript" src="../../scripts/shCore.js"></script>
  <script type="text/javascript" src="../../scripts/shBrushCpp.js"></script>

  <!-- Conditional comment to apply opacity fix for IE #content background.
       Invalid CSS, but can be removed without harming design -->
  <!--[if gt IE 5]>
  <link rel="stylesheet" type="text/css" href="css/ie.css" media="screen, projection, tv " />
  <![endif]-->
</head>

<body>
<script type="text/javascript">SyntaxHighlighter.all();</script>
<div id="wrapper">
<div id="content">
<script type="text/javascript" src="../../header.js"></script>
<div id="page">
<h3>Play Station</h3>
<p><b>反組譯Object檔案</b></p>
<hr size="1">
<pre class="brush:cpp">
// Mipsdis - Disassembler for .obj files.
// V1.0    Original version by SurfSmurf.
// V1.1    Bugfix: sra by SurfSmurf.
// V1.2    Addition: mfc0, mtc0, mtc2, mfc2, cfc2, ctc2, lwc2, swc2, cop2, rfe and GTE, cop0 register names by Doomed.
// V1.3    Adds GTE command decoding

#include  &lt;stdio.h&gt;
#include  &lt;stdlib.h&gt;
#include  &lt;stdarg.h&gt;
#include  &lt;string.h&gt;

typedef unsigned char  UBYTE;
typedef signed char    SBYTE;
typedef unsigned short  UWORD;
typedef signed short  SWORD;
typedef unsigned long  ULONG;
typedef signed long    SLONG;

#define  LITTLE_ENDIAN  0
#define  BIG_ENDIAN    1

int  iSymbolNumber=1000000;

void  Error( const char *s, ... )
{
  char  temp[256];
  va_list  list;

  list=va_start( list, s );
  vsprintf( temp, s, list );
  fprintf( stderr, "*ERROR* : %s\n", temp );
  va_end( list );
  exit( EXIT_FAILURE );
}

ULONG  fgetll( FILE *f )
{
  ULONG  r;

  r =fgetc(f);
  r|=fgetc(f)&lt;&lt;8;
  r|=fgetc(f)&lt;&lt;16;
  r|=fgetc(f)&lt;&lt;24;

  return( r );
}

UWORD  fgetlw( FILE *f )
{
  UWORD  r;

  r =fgetc(f);
  r|=fgetc(f)&lt;&lt;8;

  return( r );
}

typedef  enum
{
  OP_CONSTANT,
  OP_SECTBASE,
  OP_ADDROFSYMBOL,
  OP_ADD,
}  EOperator;

typedef  enum
{
  PATCH_LONG,
  PATCH_MIPSLO,
  PATCH_MIPSHI,
  PATCH_MIPSGP
}  EPatchType;

typedef  struct  _SExpression
{
  EOperator  Operator;

  SLONG  iValue;
  struct  _SExpression  *pLeft;
  struct  _SExpression  *pRight;
}  SExpression;

typedef  struct  _SPatch
{
  EPatchType  Type;
  SExpression  *pExpr;
  ULONG    iOffset;

  struct  _SPatch  *pNext;
}  SPatch;

typedef  enum
{
  SYM_XDEF,
  SYM_XREF,
  SYM_XBSS,
  SYM_LOCAL
}  ESymbolType;

typedef  struct  _SSymbol
{
  char    sName[256];
  ULONG    iOffset;
  ULONG    iNumber;
  ULONG    iSize;
  ESymbolType  Type;

  struct  _SSymbol  *pNext;
}  SSymbol;

typedef  struct  _SSection
{
  char  sName[256];
  ULONG  iAlign;
  UWORD  iGroup;
  ULONG  iNumber;

  UBYTE  *pData;
  ULONG  iSize;

  struct  _SSection  *pNext;
  SPatch        *pPatches;
  SSymbol        *pSymbols;
  int    oDumped;
}  SSection;

void  Disassemble( SSection *pSect );
void  ByteDump( SSection *pSect );
void  BSSDump( SSection *pSect );

SSymbol    *CreateSymbol( SSection *pSect, ESymbolType iType )
{
  SSymbol  *s;

  s=malloc( sizeof(SSymbol) );
  s-&gt;pNext=pSect-&gt;pSymbols;
  s-&gt;Type=iType;

  pSect-&gt;pSymbols=s;

  return s;
}

SPatch    *CreatePatch( SSection *pSect, EPatchType iType )
{
  SPatch  *p;

  p=malloc( sizeof(SPatch) );
  p-&gt;pNext=pSect-&gt;pPatches;
  p-&gt;pExpr=NULL;
  p-&gt;Type=iType;

  pSect-&gt;pPatches=p;

  return p;
}

SExpression  *Expr_Constant( SLONG iConst )
{
  SExpression  *expr;

  expr=malloc( sizeof(SExpression) );
  expr-&gt;pLeft=NULL;
  expr-&gt;pRight=NULL;
  expr-&gt;iValue=iConst;
  expr-&gt;Operator=OP_CONSTANT;

  return expr;
}

SExpression  *Expr_SectBase( UWORD iSect )
{
  SExpression  *expr;

  expr=malloc( sizeof(SExpression) );
  expr-&gt;pLeft=NULL;
  expr-&gt;pRight=NULL;
  expr-&gt;iValue=iSect;
  expr-&gt;Operator=OP_SECTBASE;

  return expr;
}

SExpression  *Expr_AddrOfSymbol( ULONG iSymbol )
{
  SExpression  *expr;

  expr=malloc( sizeof(SExpression) );
  expr-&gt;pLeft=NULL;
  expr-&gt;pRight=NULL;
  expr-&gt;iValue=iSymbol;
  expr-&gt;Operator=OP_ADDROFSYMBOL;

  return expr;
}

SExpression  *Expr_Add( SExpression *pLeft, SExpression *pRight )
{
  SExpression  *expr;

  expr=malloc( sizeof(SExpression) );
  expr-&gt;pLeft=pLeft;
  expr-&gt;pRight=pRight;
  expr-&gt;Operator=OP_ADD;

  return expr;
}

SExpression  *ReadExpression( FILE *f )
{
  int  op;

  op=fgetc( f );

  switch( op )
  {
    case  0x00:
      return Expr_Constant(fgetll(f));
      break;
    case  0x02:
      return Expr_AddrOfSymbol(fgetlw(f));
      break;
    case  0x04:
      return Expr_SectBase(fgetlw(f));
      break;
    case  0x2C:
      return Expr_Add(ReadExpression(f),ReadExpression(f));
      break;
    default:
      Error( "Unsupported op 0x%02X in patch at 0x%X", op, ftell( f ) );
      break;
  }

  //  args:
  //  0, constant(LONG)
  //  4, sectbase(WORD)

  return NULL;
}

SSection  *pSections=NULL;

SSection  *GetSection( ULONG iID )
{
  SSection  **ppSect=&amp;pSections;

  while( *ppSect )
  {
    if( (*ppSect)-&gt;iNumber==iID )
    {
      return *ppSect;
    }
    ppSect=&amp;((*ppSect)-&gt;pNext);
  }

  *ppSect=malloc(sizeof(SSection));
  (*ppSect)-&gt;pNext=NULL;
  (*ppSect)-&gt;iNumber=iID;
  (*ppSect)-&gt;pData=NULL;
  (*ppSect)-&gt;iSize=0;
  (*ppSect)-&gt;pPatches=NULL;
  (*ppSect)-&gt;pSymbols=NULL;
  (*ppSect)-&gt;oDumped=0;

  return *ppSect;
}

void  SectionDump( SSection *pSect )
{
  if( pSect-&gt;oDumped )
    return;

  if( pSect-&gt;iNumber==0 )
  {
    SSymbol  *pSym;

    pSym=pSect-&gt;pSymbols;
    while( pSym )
    {
      printf( "\tXREF\t%s\n", pSym-&gt;sName );
      pSym=pSym-&gt;pNext;
    }
    printf( "\n" );
  }
  else
  {
    if( (strcmp(pSect-&gt;sName,".text")==0)
    ||  (strcmp(pSect-&gt;sName,".ctors")==0)
    ||  (strcmp(pSect-&gt;sName,".dtors")==0) )
    {
      printf( "\tSECTION\t%s\n\n", pSect-&gt;sName );
      Disassemble( pSect );
      pSect-&gt;oDumped=1;
      printf( "\n\n\n\n" );
    }
    else if( (strcmp(pSect-&gt;sName,".data")==0)
    ||     (strcmp(pSect-&gt;sName,".rdata")==0)
    ||     (strcmp(pSect-&gt;sName,".sdata")==0) )
    {
      printf( "\tSECTION\t%s\n\n", pSect-&gt;sName );
      ByteDump( pSect );
      pSect-&gt;oDumped=1;
      printf( "\n\n\n\n" );
    }
    else if( (strcmp(pSect-&gt;sName,".sbss")==0)
    ||     (strcmp(pSect-&gt;sName,".bss")==0) )
    {
      printf( "\tSECTION\t%s\n\n", pSect-&gt;sName );
      BSSDump( pSect );
      pSect-&gt;oDumped=1;
      printf( "\n\n\n\n" );
    }
    else
    {
      printf( "\tSECTION\t%s\n\n", pSect-&gt;sName );
      printf( "; NOT IMPLEMENTED\n\n\n\n" );
    }
  }
}

char  *reg[32]=
{
  "zero", "at", "v0", "v1", "a0", "a1", "a2", "a3",
  "t0", "t1", "t2", "t3", "t4", "t5", "t6", "t7",
  "s0", "s1", "s2", "s3", "s4", "s5", "s6", "s7",
  "t8", "t9", "k0", "k1", "gp", "sp", "s8", "ra"
};

char  *c0reg[32]=
{
  "inx", "rand", "tlblo", "bpc", "ctxt", "bda", "pidmask", "dcic", 
  "badvaddr",  "bdam", "tlbhi", "bpcm", "sr", "cause", "epc", "prid", 
  "erreg", "r17", "r18", "r19", "r20", "r21", "r22", "r23",
  "r24", "r25", "r26", "r27", "r28", "r29", "r30", "r31"
};

char  *c2dreg[32]=
{
  "vxy0", "vz0", "vxy1", "vz1", "vxy2", "vz2", "rgb", "otz",
  "ir0", "ir1", "ir2", "ir3", "sxy0", "sxy1", "sxy2", "sxyp",
  "sz0", "sz1", "sz2", "sz3", "rgb0", "rgb1", "rgb2", "r23",
  "mac0", "mac1", "mac2", "mac3", "irgb", "orgb", "lzcs", "lzcr"
};

char  *c2creg[32]=
{
  "r11r12", "r13r21", "r22r23", "r31r32", "r33", "trx", "try", "trz",
  "l11l12", "l13l21", "l22l23", "l31l32", "l33", "rbk", "gbk", "bbk",
  "lr1lr2", "lr3lg1", "lg2lg3", "lb1lb2", "lb3", "rfc", "gfc", "bfc",
  "ofx","ofy", "h", "dqa", "dqb", "zsf3", "zsf4", "flag"
};


void  PrintUsage( void )
{
  printf( "MipsDis V1.3 by SurfSmurf, Minor updates by Doomed.\n"
      "\n"
      "Usage: ObjDis file.obj\n" );
  exit( 0 );
}

void  FreeExpression( SExpression *pExpr )
{
  if( pExpr )
  {
    FreeExpression( pExpr-&gt;pLeft );
    FreeExpression( pExpr-&gt;pRight );
    free( pExpr );
  }
}

void  FixPatchesAndSymbols( void )
{
  SSection  *pSect;

  pSect=pSections;

  while( pSect )
  {
    SPatch  *pPatch;

    pPatch=pSect-&gt;pPatches;
    while( pPatch )
    {
      SExpression  *pExpr=pPatch-&gt;pExpr;

      if( pExpr-&gt;Operator==OP_ADD
      &amp;&amp;  (  (pExpr-&gt;pLeft-&gt;Operator==OP_SECTBASE
          &amp;&amp;  pExpr-&gt;pRight-&gt;Operator==OP_CONSTANT)
        ||  (pExpr-&gt;pRight-&gt;Operator==OP_SECTBASE
          &amp;&amp;  pExpr-&gt;pLeft-&gt;Operator==OP_CONSTANT)))
      {
        SExpression  *pSectExpr;
        SExpression  *pConstExpr;
        SSymbol    *pSym;
        SSection  *pSymSect;

        pSectExpr=pExpr-&gt;pLeft;
        pConstExpr=pExpr-&gt;pRight;

        if( pSectExpr-&gt;Operator!=OP_SECTBASE )
        {
          SExpression  *t;

          t=pSectExpr;
          pSectExpr=pConstExpr;
          pConstExpr=t;
        }

        pSymSect=GetSection( pSectExpr-&gt;iValue );

        pSym=pSymSect-&gt;pSymbols;
        while( pSym )
        {
          if( pSym-&gt;iOffset==pConstExpr-&gt;iValue )
            break;
          pSym=pSym-&gt;pNext;
        }

        if( pSym==NULL )
        {
          pSym=CreateSymbol( pSymSect, SYM_LOCAL );
          pSym-&gt;iNumber=iSymbolNumber;
          pSym-&gt;iOffset=pConstExpr-&gt;iValue;
          sprintf( pSym-&gt;sName, "%s_%X", pSymSect-&gt;sName+1, pSym-&gt;iOffset );
          iSymbolNumber+=1;
        }
        FreeExpression( pExpr );
        pPatch-&gt;pExpr=Expr_AddrOfSymbol( pSym-&gt;iNumber );

      }

      pPatch=pPatch-&gt;pNext;
    }
    pSect=pSect-&gt;pNext;
  }
}

void  FixRelativeJumps( SSection *pSect );

int  main( int argc, char *argv[] )
{
  SSection  *pCurrentSection=NULL;
  FILE  *f;
  ULONG  id;
  int    ok=1;
  int    totalsections=0;
  int    PatchOffset=0;

  if( argc==1 )
    PrintUsage();

  if( (f=fopen(argv[1],"rb"))==NULL )
    Error( "File \"%s\" not found", argv[1] );

  id=fgetll( f );
  if( id!=0x024B4E4C )
    Error( "Not an object-file" );

  while( ok )
  {
    int  chunk;

    chunk=fgetc( f );
    switch( chunk )
    {
      case  0:
      {
        ok=0;
        break;
      }
      case  2:
      {
        //  Code
        int  len;

        len=fgetlw( f );
        pCurrentSection-&gt;pData=realloc( pCurrentSection-&gt;pData, pCurrentSection-&gt;iSize+len );
        fread( pCurrentSection-&gt;pData+pCurrentSection-&gt;iSize, 1, len, f );
        pCurrentSection-&gt;iSize+=len;
        break;
      }
      case  6:
      {
        //  Switch to section
        int  id;

        id=fgetlw( f );
        pCurrentSection=GetSection( id );
        PatchOffset=pCurrentSection-&gt;iSize;
        break;
      }
      case  8:
      {
        //  Uninitialised data
        int  size;

        size=fgetll( f );

        pCurrentSection-&gt;iSize+=size;
        break;
      }
      case  10:
      {
        //  Patch
        int      type;
        int      offset;
        EPatchType  ntype;
        SPatch  *p;

        type=fgetc( f );
        offset=fgetlw( f );

        switch( type )
        {
          case  16:
            ntype=PATCH_LONG;
            break;
          case  74:
            ntype=PATCH_LONG;
            break;
          case  82:
            ntype=PATCH_MIPSHI;
            break;
          case  84:
            ntype=PATCH_MIPSLO;
            break;
          case  100:
            ntype=PATCH_MIPSGP;
            break;
          default:
            Error( "Patch type %d at 0x%X unsupported", type, ftell(f) );
        }
        p=CreatePatch( pCurrentSection, ntype );
        p-&gt;iOffset=offset+PatchOffset;
        p-&gt;pExpr=ReadExpression( f );

        break;
      }
      case  12:
      {
        //  XDEF symbol
        int    number;
        int    section;
        int    len;
        ULONG  offset;
        SSymbol  *pSym;

        number=fgetlw( f );
        section=fgetlw( f );
        offset=fgetll( f );

        pSym=CreateSymbol(GetSection(section),SYM_XDEF);
        pSym-&gt;iOffset=offset;
        pSym-&gt;iNumber=number;
        len=fgetc(f);
        fread( pSym-&gt;sName, 1, len, f );
        pSym-&gt;sName[len]=0;
        break;
      }
      case  14:
      {
        //  XREF symbol
        int    number;
        int    len;

        SSymbol  *pSym;

        number=fgetlw( f );

        pSym=CreateSymbol(GetSection(0),SYM_XREF);
        pSym-&gt;iNumber=number;
        len=fgetc(f);
        fread( pSym-&gt;sName, 1, len, f );
        pSym-&gt;sName[len]=0;
        break;
      }
      case  16:
      {
        //  Create section
        SSection  *pSect;
        int      len;
        int      id;

        pSect=GetSection( id=fgetlw(f) );
        pSect-&gt;iGroup=fgetc( f );  //  GROUP
        pSect-&gt;iAlign=fgetlw( f );  //  ALIGNMENT

        len=fgetc( f );
        fread( pSect-&gt;sName, 1, len, f );
        pSect-&gt;sName[len]=0;

        if( id&gt;totalsections )
        {
          totalsections=id;
        }
        break;
      }
      case  18:
      {
        //  LOCAL symbol
        int    section;
        int    len;
        ULONG  offset;
        SSymbol  *pSym;

        section=fgetlw( f );
        offset=fgetll( f );

        pSym=CreateSymbol(GetSection(section),SYM_LOCAL);
        pSym-&gt;iOffset=offset;
        pSym-&gt;iNumber=iSymbolNumber++;
        len=fgetc(f);
        fread( pSym-&gt;sName, 1, len, f );
        pSym-&gt;sName[len]=0;
        break;
      }
      case  28:
      {
        //  File number and name
        int  number;
        int  len;

        number=fgetlw( f );
        len=fgetc( f );
        fseek( f, len, SEEK_CUR );

        break;
      }
      case  46:
      {
        //  CPU type

        int  cpu;
        cpu=fgetc( f );
        if( cpu!=7 )
          Error( "CPU type %d not supported", cpu );
        break;
      }
      case  48:
      {
        //  XBSS symbol
        int    number;
        int    section;
        int    len;
        ULONG  size;
        SSymbol  *pSym;
        SSection  *pSect;

        number=fgetlw( f );
        section=fgetlw( f );
        size=fgetll( f );

        pSect=GetSection(section);

        pSym=CreateSymbol(pSect,SYM_XBSS);
        pSym-&gt;iOffset=pSect-&gt;iSize;
        pSym-&gt;iSize=size;
        pSect-&gt;iSize+=size;
        pSym-&gt;iNumber=number;
        len=fgetc(f);
        fread( pSym-&gt;sName, 1, len, f );
        pSym-&gt;sName[len]=0;
        break;

      }
      default:
        Error( "Chunk %d at 0x%X not supported", chunk, ftell(f) );
    }
  }

  printf( "\tOPT\tc+,at-,m-\n"
      "\n"
      "\txref\t__SN_GP_BASE\n"
      "\n" );

  FixPatchesAndSymbols();
  SectionDump( GetSection(0) );
  pCurrentSection=pSections;
  while( pCurrentSection )
  {
    if( strcmp(pCurrentSection-&gt;sName,".text")==0 )
    {
      FixRelativeJumps( pCurrentSection );
    }
    pCurrentSection=pCurrentSection-&gt;pNext;
  }

  pCurrentSection=pSections;
  while( pCurrentSection )
  {
    if( (pCurrentSection-&gt;iNumber!=0)
    &amp;&amp;  (  (strcmp(pCurrentSection-&gt;sName,".sbss")==0)
      ||  (strcmp(pCurrentSection-&gt;sName,".sdata")==0)) )
    {
      SectionDump( pCurrentSection );
    }
    pCurrentSection=pCurrentSection-&gt;pNext;
  }

  printf(  "\tASSUME\tgp:__SN_GP_BASE,.sdata,.sbss\n"
      "\n" );
  pCurrentSection=pSections;
  while( pCurrentSection )
  {
    if( pCurrentSection-&gt;iNumber!=0 )
    {
      SectionDump( pCurrentSection );
    }
    pCurrentSection=pCurrentSection-&gt;pNext;
  }

//  getchar();

  fclose( f );

  return EXIT_SUCCESS;
}

void  DumpLong( ULONG data )
{
  printf( "DW\t$%08X", data );
}

SSymbol  *GetSymbol( ULONG iID )
{
  SSection  *pSect;

  pSect=pSections;
  while( pSect )
  {
    SSymbol  *pSym;

    pSym=pSect-&gt;pSymbols;
    while( pSym )
    {
      if( pSym-&gt;iNumber==iID )
      {
        return pSym;
      }
      pSym=pSym-&gt;pNext;
    }
    pSect=pSect-&gt;pNext;
  }

  return NULL;
}

char  *GetSymbolName( SSection *pSect, ULONG iOffset, SLONG iRel )
{
  static  char  temp[256];
  SSymbol  *pSym;

  iOffset+=iRel;

  pSym=pSect-&gt;pSymbols;
  while( pSym )
  {
    if( pSym-&gt;iOffset==iOffset )
    {
      sprintf( temp, "%s", pSym-&gt;sName );
      return temp;
    }
    pSym=pSym-&gt;pNext;
  }

  sprintf( temp, "*%+d", iRel );
  return temp;
}

char  *FormatExpr( SExpression *pExpr, char *pBuf )
{
  switch( pExpr-&gt;Operator )
  {
    case  OP_CONSTANT:
      sprintf( pBuf, "$%X", pExpr-&gt;iValue );
      break;
    case  OP_SECTBASE:
      sprintf( pBuf, "sectbase(%s)", GetSection(pExpr-&gt;iValue)-&gt;sName );
      break;
    case  OP_ADDROFSYMBOL:
      sprintf( pBuf, "%s", GetSymbol(pExpr-&gt;iValue)-&gt;sName );
      break;
    case  OP_ADD:
      pBuf=FormatExpr( pExpr-&gt;pLeft, pBuf );
      sprintf( pBuf, "+" );
      pBuf+=1;
      pBuf=FormatExpr( pExpr-&gt;pRight, pBuf );
      break;
  }

  return pBuf+strlen(pBuf);
}

char  *WordPatch( SPatch *pPatch, const char *fmt, ULONG data )
{
  static  char  temp[256];

  if( pPatch )
  {
    char  *s=temp;

    if( pPatch-&gt;Type==PATCH_MIPSLO )
    {
      strcpy( s, "_lo(" );
      s+=strlen(s);
      s=FormatExpr( pPatch-&gt;pExpr, s );  
      strcpy( s, ")" );
    }
    else if( pPatch-&gt;Type==PATCH_MIPSHI )
    {
      strcpy( s, "_hi(" );
      s+=strlen(s);
      s=FormatExpr( pPatch-&gt;pExpr, s );  
      strcpy( s, ")" );
    }
    else if( pPatch-&gt;Type==PATCH_MIPSGP )
    {
      //strcpy( s, "_gp(" );
      //s+=strlen(s);
      s=FormatExpr( pPatch-&gt;pExpr, s );
      //strcpy( s, ")" );
      strcpy( s, "\t;" );
    }
    else
    {
      s=FormatExpr( pPatch-&gt;pExpr, s );  
    }
  }
  else
  {
    sprintf( temp, fmt, data );
  }

  return temp;
}

void  Disassemble( SSection *pSect )
{
  ULONG  index=0;
  ULONG  size;
  ULONG  PC=0;
  SSymbol  *pSym;

  pSym=pSect-&gt;pSymbols;
  while( pSym )
  {
    if( pSym-&gt;Type==SYM_XDEF )
    {
      printf( "\tXDEF\t%s\n", pSym-&gt;sName );
    }
    pSym=pSym-&gt;pNext;
  }

  size=pSect-&gt;iSize;

  while( size )
  {
    ULONG  data;
    ULONG  code1,
        code2;
    SPatch  *pPatch;

    pSym=pSect-&gt;pSymbols;
    while( pSym )
    {
      if( pSym-&gt;iOffset==index )
      {
        if( pSym-&gt;Type==SYM_XDEF )
        {
          printf( "\n" );
        }
        printf( "%s:\n", pSym-&gt;sName );
        break;
      }
      pSym=pSym-&gt;pNext;
    }

    pPatch=pSect-&gt;pPatches;
    while( pPatch )
    {
      if( (pPatch-&gt;iOffset&gt;=index) &amp;&amp; (pPatch-&gt;iOffset&lt;=index+3) )
      {
        break;
      }
      pPatch=pPatch-&gt;pNext;
    }

    data =pSect-&gt;pData[index++];
    data|=pSect-&gt;pData[index++]&lt;&lt;8;
    data|=pSect-&gt;pData[index++]&lt;&lt;16;
    data|=pSect-&gt;pData[index++]&lt;&lt;24;
    size-=4;

    printf( "\t" );
    PC+=4;

    code1=(data&gt;&gt;29)&amp;0x7;
    code2=(data&gt;&gt;26)&amp;0x7;

    switch( code1 )
    {
      case 0:
        switch( code2 )
        {
          case 0:
            //  SPECIAL function
            {
              ULONG  code3,
                  code4;

              code3=(data&gt;&gt;3)&amp;0x7;
              code4=(data&gt;&gt;0)&amp;0x7;

              switch( code3 )
              {
                case 0:
                  switch( code4 )
                  {
                    case 0:
                      if( data==0 )
                        printf( "nop" );
                      else
                        printf( "sll\t%s,%s,%d", reg[(data&gt;&gt;11)&amp;0x1F], reg[(data&gt;&gt;16)&amp;0x1F], (data&gt;&gt;6)&amp;0x1F );
                      break;
                    case 2:
                      printf( "srl\t%s,%s,%d", reg[(data&gt;&gt;11)&amp;0x1F], reg[(data&gt;&gt;16)&amp;0x1F], (data&gt;&gt;6)&amp;0x1F );
                      break;
                    case 3:
                      printf( "sra\t%s,%s,%d", reg[(data&gt;&gt;11)&amp;0x1F], reg[(data&gt;&gt;16)&amp;0x1F], (data&gt;&gt;6)&amp;0x1F );
                      break;
                    case 4:
                      printf( "sllv\t%s,%s,%s", reg[(data&gt;&gt;11)&amp;0x1F], reg[(data&gt;&gt;16)&amp;0x1F], reg[(data&gt;&gt;21)&amp;0x1F] );
                      break;
                    case 6:
                      printf( "srlv\t%s,%s,%s", reg[(data&gt;&gt;11)&amp;0x1F], reg[(data&gt;&gt;16)&amp;0x1F], reg[(data&gt;&gt;21)&amp;0x1F] );
                      break;
                    case 7:
                      printf( "srav\t%s,%s,%s", reg[(data&gt;&gt;11)&amp;0x1F], reg[(data&gt;&gt;16)&amp;0x1F], reg[(data&gt;&gt;21)&amp;0x1F] );
                      break;
                    default:
                      DumpLong( data );
                      break;
                  }
                  break;
                case 1:
                  switch( code4 )
                  {
                    case 0:
                      printf( "jr\t%s", reg[(data&gt;&gt;21)&amp;0x1F] );
                      break;
                    case 1:
                      printf( "jalr\t%s,%s", reg[(data&gt;&gt;11)&amp;0x1F], reg[(data&gt;&gt;21)&amp;0x1F] );
                      break;
                    case 4:
                      printf( "syscall\t$%X", (data&gt;&gt;6)&amp;0xFFFFF );
                      break;
                    case 5:
                      printf( "break\t$%X", (data&gt;&gt;6)&amp;0xFFFFF );
                      break;
                    default:
                      DumpLong( data );
                      break;
                  }
                  break;
                case 2:
                  switch( code4 )
                  {
                    case 0:
                      printf( "mfhi\t%s", reg[(data&gt;&gt;11)&amp;0x1F] );
                      break;
                    case 1:
                      printf( "mthi\t%s", reg[(data&gt;&gt;11)&amp;0x1F] );
                      break;
                    case 2:
                      printf( "mflo\t%s", reg[(data&gt;&gt;11)&amp;0x1F] );
                      break;
                    case 3:
                      printf( "mtlo\t%s", reg[(data&gt;&gt;11)&amp;0x1F] );
                      break;
                    default:
                      DumpLong( data );
                      break;
                  }
                  break;
                case 3:
                  switch( code4 )
                  {
                    case 0:
                      printf( "mult\t%s,%s", reg[(data&gt;&gt;21)&amp;0x1F], reg[(data&gt;&gt;16)&amp;0x1F] );
                      break;
                    case 1:
                      printf( "multu\t%s,%s", reg[(data&gt;&gt;21)&amp;0x1F], reg[(data&gt;&gt;16)&amp;0x1F] );
                      break;
                    case 2:
                      printf( "div\t%s,%s", reg[(data&gt;&gt;21)&amp;0x1F], reg[(data&gt;&gt;16)&amp;0x1F] );
                      break;
                    case 3:
                      printf( "divu\t%s,%s", reg[(data&gt;&gt;21)&amp;0x1F], reg[(data&gt;&gt;16)&amp;0x1F] );
                      break;
                    default:
                      DumpLong( data );
                      break;
                  }
                  break;
                case 4:
                  switch( code4 )
                  {
                    case 0:
                      printf( "add\t%s,%s,%s", reg[(data&gt;&gt;11)&amp;0x1F], reg[(data&gt;&gt;21)&amp;0x1F], reg[(data&gt;&gt;16)&amp;0x1F] );
                      break;
                    case 1:
                      if( ((data&gt;&gt;16)&amp;0x1F)==0 )
                        printf( "move\t%s,%s", reg[(data&gt;&gt;11)&amp;0x1F], reg[(data&gt;&gt;21)&amp;0x1F] );
                      else
                        printf( "addu\t%s,%s,%s", reg[(data&gt;&gt;11)&amp;0x1F], reg[(data&gt;&gt;21)&amp;0x1F], reg[(data&gt;&gt;16)&amp;0x1F] );
                      break;
                    case 2:
                      printf( "sub\t%s,%s,%s", reg[(data&gt;&gt;11)&amp;0x1F], reg[(data&gt;&gt;21)&amp;0x1F], reg[(data&gt;&gt;16)&amp;0x1F] );
                      break;
                    case 3:
                      printf( "subu\t%s,%s,%s", reg[(data&gt;&gt;11)&amp;0x1F], reg[(data&gt;&gt;21)&amp;0x1F], reg[(data&gt;&gt;16)&amp;0x1F] );
                      break;
                    case 4:
                      printf( "and\t%s,%s,%s", reg[(data&gt;&gt;11)&amp;0x1F], reg[(data&gt;&gt;21)&amp;0x1F], reg[(data&gt;&gt;16)&amp;0x1F] );
                      break;
                    case 5:
                      printf( "or\t%s,%s,%s", reg[(data&gt;&gt;11)&amp;0x1F], reg[(data&gt;&gt;21)&amp;0x1F], reg[(data&gt;&gt;16)&amp;0x1F] );
                      break;
                    case 6:
                      printf( "xor\t%s,%s,%s", reg[(data&gt;&gt;11)&amp;0x1F], reg[(data&gt;&gt;21)&amp;0x1F], reg[(data&gt;&gt;16)&amp;0x1F] );
                      break;
                    case 7:
                      printf( "nor\t%s,%s,%s", reg[(data&gt;&gt;11)&amp;0x1F], reg[(data&gt;&gt;21)&amp;0x1F], reg[(data&gt;&gt;16)&amp;0x1F] );
                      break;
                  }
                  break;
                case 5:
                  switch( code4 )
                  {
                    case 2:
                      printf( "slt\t%s,%s,%s", reg[(data&gt;&gt;11)&amp;0x1F], reg[(data&gt;&gt;21)&amp;0x1F], reg[(data&gt;&gt;16)&amp;0x1F] );
                      break;
                    case 3:
                      printf( "sltu\t%s,%s,%s", reg[(data&gt;&gt;11)&amp;0x1F], reg[(data&gt;&gt;21)&amp;0x1F], reg[(data&gt;&gt;16)&amp;0x1F] );
                      break;
                    default:
                      DumpLong( data );
                      break;
                  }
                  break;
                case 6:
                  switch( code4 )
                  {
                    case 0:
                      printf( "tge\t%s,%s", reg[(data&gt;&gt;21)&amp;0x1F], reg[(data&gt;&gt;16)&amp;0x1F] );
                      break;
                    case 1:
                      printf( "tgeu\t%s,%s", reg[(data&gt;&gt;21)&amp;0x1F], reg[(data&gt;&gt;16)&amp;0x1F] );
                      break;
                    case 2:
                      printf( "tlt\t%s,%s", reg[(data&gt;&gt;21)&amp;0x1F], reg[(data&gt;&gt;16)&amp;0x1F] );
                      break;
                    case 3:
                      printf( "tltu\t%s,%s", reg[(data&gt;&gt;21)&amp;0x1F], reg[(data&gt;&gt;16)&amp;0x1F] );
                      break;
                    case 4:
                      printf( "teq\t%s,%s", reg[(data&gt;&gt;21)&amp;0x1F], reg[(data&gt;&gt;16)&amp;0x1F] );
                      break;
                    case 6:
                      printf( "tne\t%s,%s", reg[(data&gt;&gt;21)&amp;0x1F], reg[(data&gt;&gt;16)&amp;0x1F] );
                      break;
                    default:
                      DumpLong( data );
                      break;
                  }
                  break;
                default:
                  DumpLong( data );
                  break;
              }
            }
            break;
          case 1:
          //  REGIMM function
          {
            ULONG  code3,
                code4;

            code3=(data&gt;&gt;19)&amp;0x3;
            code4=(data&gt;&gt;16)&amp;0x7;

            switch( code3 )
            {
              case 0:
                switch( code4 )
                {
                  case 0:
                    printf( "bltz\t%s,%s", reg[(data&gt;&gt;21)&amp;0x1F], GetSymbolName(pSect,index,((SWORD)data)&lt;&lt;2) );
                    break;
                  case 1:
                    printf( "bgez\t%s,%s", reg[(data&gt;&gt;21)&amp;0x1F], GetSymbolName(pSect,index,((SWORD)data)&lt;&lt;2) );
                    break;
                  case 2:
                    printf( "bltzl\t%s,%s", reg[(data&gt;&gt;21)&amp;0x1F], GetSymbolName(pSect,index,((SWORD)data)&lt;&lt;2) );
                    break;
                  case 3:
                    printf( "bgezl\t%s,%s", reg[(data&gt;&gt;21)&amp;0x1F], GetSymbolName(pSect,index,((SWORD)data)&lt;&lt;2) );
                    break;
                  default:
                    DumpLong( data );
                    break;
                }
                break;
              default:
                DumpLong( data );
                break;
            }
            break;
          }
          case 2:
            printf( "j\t%s", WordPatch(pPatch,"$%07X", ((data&amp;0x03FFFFFF)&lt;&lt;2)) );
            break;
          case 3:
            printf( "jal\t%s", WordPatch(pPatch,"$%07X", ((data&amp;0x03FFFFFF)&lt;&lt;2)) );
            break;
          case 4:
            if( ((data&gt;&gt;16)&amp;0x1F)==0 )
              printf( "beqz\t%s,%s", reg[(data&gt;&gt;21)&amp;0x1F], GetSymbolName(pSect,index,((SWORD)data)&lt;&lt;2) );
            else
              printf( "beq\t%s,%s,%s", reg[(data&gt;&gt;21)&amp;0x1F], reg[(data&gt;&gt;16)&amp;0x1F], GetSymbolName(pSect,index,((SWORD)data)&lt;&lt;2) );
            break;
          case 5:
            if( ((data&gt;&gt;16)&amp;0x1F)==0 )
              printf( "bnez\t%s,%s", reg[(data&gt;&gt;21)&amp;0x1F], GetSymbolName(pSect,index,((SWORD)data)&lt;&lt;2) );
            else
              printf( "bne\t%s,%s,%s", reg[(data&gt;&gt;21)&amp;0x1F], reg[(data&gt;&gt;16)&amp;0x1F], GetSymbolName(pSect,index,((SWORD)data)&lt;&lt;2) );
            break;
          case 6:
            printf( "blez\t%s,%s", reg[(data&gt;&gt;21)&amp;0x1F], GetSymbolName(pSect,index,((SWORD)data)&lt;&lt;2) );
            break;
          case 7:
            printf( "bgtz\t%s,%s", reg[(data&gt;&gt;21)&amp;0x1F], GetSymbolName(pSect,index,((SWORD)data)&lt;&lt;2) );
            break;
        }
        break;
      case 1:
        switch( code2 )
        {
          case 0:
            printf( "addi\t%s,%s,%s", reg[(data&gt;&gt;16)&amp;0x1F], reg[(data&gt;&gt;21)&amp;0x1F], WordPatch(pPatch,"%d",(SWORD)data) );
            break;
          case 1:
            if( ((data&gt;&gt;21)&amp;0x1F)==0 )
              printf( "li\t%s,%s", reg[(data&gt;&gt;16)&amp;0x1F], WordPatch(pPatch,"%d",(SWORD)data) );
            else
              printf( "addiu\t%s,%s,%s", reg[(data&gt;&gt;16)&amp;0x1F], reg[(data&gt;&gt;21)&amp;0x1F], WordPatch(pPatch,"%d",(SWORD)data) );
            break;
          case 2:
            printf( "slti\t%s,%s,%s", reg[(data&gt;&gt;16)&amp;0x1F], reg[(data&gt;&gt;21)&amp;0x1F], WordPatch(pPatch,"%d",(SWORD)data) );
            break;
          case 3:
            printf( "sltiu\t%s,%s,%s", reg[(data&gt;&gt;16)&amp;0x1F], reg[(data&gt;&gt;21)&amp;0x1F], WordPatch(pPatch,"%d",(SWORD)data) );
            break;
          case 4:
            printf( "andi\t%s,%s,%s", reg[(data&gt;&gt;16)&amp;0x1F], reg[(data&gt;&gt;21)&amp;0x1F], WordPatch(pPatch,"$%04X",(UWORD)data) );
            break;
          case 5:
            printf( "ori\t%s,%s,%s", reg[(data&gt;&gt;16)&amp;0x1F], reg[(data&gt;&gt;21)&amp;0x1F], WordPatch(pPatch,"$%04X",(UWORD)data) );
            break;
          case 6:
            printf( "xori\t%s,%s,%s", reg[(data&gt;&gt;16)&amp;0x1F], reg[(data&gt;&gt;21)&amp;0x1F], WordPatch(pPatch,"$%04X",(UWORD)data) );
            break;
          case 7:
            printf( "lui\t%s,%s", reg[(data&gt;&gt;16)&amp;0x1F], WordPatch(pPatch,"$%04X",(UWORD)data) );
            break;
        }
        break;
      case 2:
        switch( code2 )
        {
          case 0:
            {
            ULONG code3;

              code3 = (data&gt;&gt;21)&amp;0x1f;

              switch (code3)
              {
                case 0:
                  printf( "mfc0\t%s,%s", reg[(data&gt;&gt;16)&amp;0x1F], c0reg[(data&gt;&gt;11)&amp;0x1F] );
                  break;
                case 4:
                  printf( "mtc0\t%s,%s", reg[(data&gt;&gt;16)&amp;0x1F], c0reg[(data&gt;&gt;11)&amp;0x1F] );
                  break;
                case 16:
                  if (data&amp;0x1f == 16)
                    printf ("rfe");
                  else DumpLong(data);
                  break;
                default:
                  DumpLong( data );
                  break;
                
              }
            }
            break;
          case 2:
            {
            ULONG code3;

              code3 = (data&gt;&gt;25)&amp;0x1;

              if (code3 == 1) 
              {
                data&amp;=0x1FFFFFF;

                if( (data&amp;0x1F003FF)==0x0400012 )
                  printf( "mvmva\t%d,%d,%d,%d,%d", (data&gt;&gt;19)&amp;1, (data&gt;&gt;17)&amp;3, (data&gt;&gt;15)&amp;3, (data&gt;&gt;13)&amp;3, (data&gt;&gt;10)&amp;1 );  //  sf,mx,v,cv,lm
                else if( (data&amp;0x1F003FF)==0x0a00428 )
                  printf( "sqr\t%d", (data&gt;&gt;19)&amp;1 );
                else if( (data&amp;0x1F003FF)==0x170000C )
                  printf( "op\t%d", (data&gt;&gt;19)&amp;1 );
                else if( (data&amp;0x1F003FF)==0x190003D )
                  printf( "gpf\t%d", (data&gt;&gt;19)&amp;1 );
                else if( (data&amp;0x1F003FF)==0x1A0003E )
                  printf( "gpl\t%d", (data&gt;&gt;19)&amp;1 );
                else if( data==0x0180001 )
                  printf( "rtps" );
                else if( data==0x0280030 )
                  printf( "rtpt" );
                else if( data==0x0680029 )
                  printf( "dcpl" );
                else if( data==0x0780010 )
                  printf( "dcps" );
                else if( data==0x0980011 )
                  printf( "intpl" );
                else if( data==0x0C8041E )
                  printf( "ncs" );
                else if( data==0x0D80420 )
                  printf( "nct" );
                else if( data==0x0E80413 )
                  printf( "ncds" );
                else if( data==0x0F80416 )
                  printf( "ncdt" );
                else if( data==0x0F8002A )
                  printf( "dpct" );
                else if( data==0x108041B )
                  printf( "nccs" );
                else if( data==0x118043F )
                  printf( "ncct" );
                else if( data==0x1280414 )
                  printf( "cdp" );
                else if( data==0x138041C )
                  printf( "cc" );
                else if( data==0x1400006 )
                  printf( "nclip" );
                else if( data==0x158002D )
                  printf( "avsz3" );
                else if( data==0x168002E )
                  printf( "avsz4" );
                else
                  printf ("cop2\t$%x", data&amp;0x1FFFFFF);
              }
              else
              {
                code3 = (data&gt;&gt;21)&amp;0x1F;
                switch(code3)
                {
                  case 0:
                    printf( "mfc2\t%s,%s", reg[(data&gt;&gt;16)&amp;0x1F], c2dreg[(data&gt;&gt;11)&amp;0x1F] );
                    break;
                  case 2:
                    printf( "cfc2\t%s,%s", reg[(data&gt;&gt;16)&amp;0x1F], c2creg[(data&gt;&gt;11)&amp;0x1F] );
                    break;
                  case 4:
                    printf( "mtc2\t%s,%s", reg[(data&gt;&gt;16)&amp;0x1F], c2dreg[(data&gt;&gt;11)&amp;0x1F] );
                    break;  
                  case 6:
                    printf( "ctc2\t%s,%s", reg[(data&gt;&gt;16)&amp;0x1F], c2creg[(data&gt;&gt;11)&amp;0x1F] );
                    break;  
                  default:
                    DumpLong( data );
                    break;
                }
              }

            }
            break;
            case 4:
            printf( "beql\t%s,%s,%s", reg[(data&gt;&gt;21)&amp;0x1F], reg[(data&gt;&gt;16)&amp;0x1F], GetSymbolName(pSect,index,((SWORD)data)&lt;&lt;2) );
            break;
          case 5:
            printf( "bnel\t%s,%s,%s", reg[(data&gt;&gt;21)&amp;0x1F], reg[(data&gt;&gt;16)&amp;0x1F], GetSymbolName(pSect,index,((SWORD)data)&lt;&lt;2) );
            break;
          case 6:
            printf( "blezl\t%s,%s", reg[(data&gt;&gt;21)&amp;0x1F], GetSymbolName(pSect,index,((SWORD)data)&lt;&lt;2) );
            break;
          case 7:
            printf( "bgtzl\t%s,%s", reg[(data&gt;&gt;21)&amp;0x1F], GetSymbolName(pSect,index,((SWORD)data)&lt;&lt;2) );
            break;
          default:
            DumpLong( data );
            break;
        }
        break;
      case 4:
        switch( code2 )
        {
          case 0:
            printf( "lb\t%s,%s(%s)", reg[(data&gt;&gt;16)&amp;0x1F], WordPatch(pPatch,"%d",(SWORD)data), reg[(data&gt;&gt;21)&amp;0x1F] );
            break;
          case 1:
            printf( "lh\t%s,%s(%s)", reg[(data&gt;&gt;16)&amp;0x1F], WordPatch(pPatch,"%d",(SWORD)data), reg[(data&gt;&gt;21)&amp;0x1F] );
            break;
          case 2:
            printf( "lwl\t%s,%s(%s)", reg[(data&gt;&gt;16)&amp;0x1F], WordPatch(pPatch,"%d",(SWORD)data), reg[(data&gt;&gt;21)&amp;0x1F] );
            break;
          case 3:
            printf( "lw\t%s,%s(%s)", reg[(data&gt;&gt;16)&amp;0x1F], WordPatch(pPatch,"%d",(SWORD)data), reg[(data&gt;&gt;21)&amp;0x1F] );
            break;
          case 4:
            printf( "lbu\t%s,%s(%s)", reg[(data&gt;&gt;16)&amp;0x1F], WordPatch(pPatch,"%d",(SWORD)data), reg[(data&gt;&gt;21)&amp;0x1F] );
            break;
          case 5:
            printf( "lhu\t%s,%s(%s)", reg[(data&gt;&gt;16)&amp;0x1F], WordPatch(pPatch,"%d",(SWORD)data), reg[(data&gt;&gt;21)&amp;0x1F] );
            break;
          case 6:
            printf( "lwr\t%s,%s(%s)", reg[(data&gt;&gt;16)&amp;0x1F], WordPatch(pPatch,"%d",(SWORD)data), reg[(data&gt;&gt;21)&amp;0x1F] );
            break;
          default:
            DumpLong( data );
            break;
        }
        break;
      case 5:
        switch( code2 )
        {
          case 0:
            printf( "sb\t%s,%s(%s)", reg[(data&gt;&gt;16)&amp;0x1F], WordPatch(pPatch,"%d",(SWORD)data), reg[(data&gt;&gt;21)&amp;0x1F] );
            break;
          case 1:
            printf( "sh\t%s,%s(%s)", reg[(data&gt;&gt;16)&amp;0x1F], WordPatch(pPatch,"%d",(SWORD)data), reg[(data&gt;&gt;21)&amp;0x1F] );
            break;
          case 2:
            printf( "swl\t%s,%s(%s)", reg[(data&gt;&gt;16)&amp;0x1F], WordPatch(pPatch,"%d",(SWORD)data), reg[(data&gt;&gt;21)&amp;0x1F] );
            break;
          case 3:
            printf( "sw\t%s,%s(%s)", reg[(data&gt;&gt;16)&amp;0x1F], WordPatch(pPatch,"%d",(SWORD)data), reg[(data&gt;&gt;21)&amp;0x1F] );
            break;
          case 6:
            printf( "swr\t%s,%s(%s)", reg[(data&gt;&gt;16)&amp;0x1F], WordPatch(pPatch,"%d",(SWORD)data), reg[(data&gt;&gt;21)&amp;0x1F] );
            break;
          default:
            DumpLong( data );
            break;
        }
        break;
      case 6:
        switch( code2 )
        {
          case 0:
            printf( "ll\t%s,%s(%s)", reg[(data&gt;&gt;16)&amp;0x1F], WordPatch(pPatch,"%d",(SWORD)data), reg[(data&gt;&gt;21)&amp;0x1F] );
            break;
          case 2:
            printf( "lwc2\t%s,%s(%s)", c2dreg[(data&gt;&gt;16)&amp;0x1F], WordPatch(pPatch,"%d",(SWORD)data), reg[(data&gt;&gt;21)&amp;0x1F] );
            break;

          default:
            DumpLong( data );
            break;
        }
        break;
      case 7:
        switch( code2 )
        {
          case 2:
            printf( "swc2\t%s,%s(%s)", c2dreg[(data&gt;&gt;16)&amp;0x1F], WordPatch(pPatch,"%d",(SWORD)data), reg[(data&gt;&gt;21)&amp;0x1F] );
            break;

          default:
            DumpLong( data );
            break;
        }
        break;
      default:
        DumpLong( data );
        break;
    }
    printf( "\n" );
  }
}

void  BSSDump( SSection *pSect )
{
  SSymbol  **ppSym;
  SSymbol  *pSym;
  int  oSwapped=1;

  while( oSwapped )
  {

    ppSym=&amp;pSect-&gt;pSymbols;
    oSwapped=0;
    while( (*ppSym) &amp;&amp; (*ppSym)-&gt;pNext )
    {
      if( (*ppSym)-&gt;iOffset&gt;(*ppSym)-&gt;pNext-&gt;iOffset )
      {
        SSymbol  *t;

        t=(*ppSym);
        *ppSym=t-&gt;pNext;
        t-&gt;pNext=t;

        oSwapped=1;
      }

      ppSym=&amp;(*ppSym)-&gt;pNext;
    }
  }

  pSym=pSect-&gt;pSymbols;
  while( pSym )
  {
    int  size;

    if( pSym-&gt;pNext )
    {
      size=pSym-&gt;pNext-&gt;iOffset-pSym-&gt;iOffset;
    }
    else
    {
      size=pSect-&gt;iSize-pSym-&gt;iOffset;
    }
    printf( "%s:\tDSB\t%d\n", pSym-&gt;sName, size );
    pSym=pSym-&gt;pNext;
  }
}

void  ByteDump( SSection *pSect )
{
  ULONG  charpos=0;
  ULONG  datasize=0;
  ULONG  index=0;
  ULONG  size;
  ULONG  PC=0;
  SSymbol  *pSym;

  pSym=pSect-&gt;pSymbols;
  while( pSym )
  {
    if( pSym-&gt;Type==SYM_XDEF )
    {
      printf( "\tXDEF\t%s\n", pSym-&gt;sName );
    }
    pSym=pSym-&gt;pNext;
  }

  size=pSect-&gt;iSize;

  while( size )
  {
    SPatch  *pPatch;
    int    newdatasize;

    pSym=pSect-&gt;pSymbols;
    while( pSym )
    {
      if( pSym-&gt;iOffset==index )
      {
        if( pSym-&gt;Type==SYM_XDEF )
        {
          printf( "\n" );
        }
        printf( "\n%s:", pSym-&gt;sName );
        charpos=strlen(pSym-&gt;sName);
        datasize=0;
        break;
      }
      pSym=pSym-&gt;pNext;
    }

    pPatch=pSect-&gt;pPatches;
    while( pPatch )
    {
      if( (pPatch-&gt;iOffset&gt;=index) &amp;&amp; (pPatch-&gt;iOffset&lt;=index+3) )
      {
        break;
      }
      pPatch=pPatch-&gt;pNext;
    }

    if( charpos&gt;70 )
    {
      datasize=0;
    }

    switch( index&amp;3 )
    {
      case  0:
        newdatasize=4;
        break;
      case  1:
      case  3:
        newdatasize=1;
        break;
      case  2:
        newdatasize=2;
        break;
    }

    if( size&lt;newdatasize )
    {
      newdatasize=size;
      if( newdatasize==3 )
      {
        newdatasize=2;
      }
    }

    switch( newdatasize )
    {
      case  4:
      {
        ULONG  data;

        if( datasize!=4 )
        {
          printf( "\n\tDW\t" );
          charpos=16;
        }
        else
        {
          printf( "," );
          charpos+=1;
        }

        datasize=4;
        data =pSect-&gt;pData[index++];
        data|=pSect-&gt;pData[index++]&lt;&lt;8;
        data|=pSect-&gt;pData[index++]&lt;&lt;16;
        data|=pSect-&gt;pData[index++]&lt;&lt;24;
        printf( "$%08X", data );
        charpos+=9;
        size-=4;

        break;
      }
      case  1:
      {
        ULONG  data;

        if( datasize!=1 )
        {
          printf( "\n\tDB\t" );
          charpos=16;
        }
        else
        {
          printf( "," );
          charpos+=1;
        }

        datasize=1;
        data =pSect-&gt;pData[index++];
        printf( "$%02X", data );
        charpos+=3;
        size-=1;

        break;
      }
      case  2:
      {
        ULONG  data;

        if( datasize!=2 )
        {
          printf( "\n\tDH\t" );
          charpos=16;
        }
        else
        {
          printf( "," );
          charpos+=1;
        }

        datasize=2;
        data =pSect-&gt;pData[index++];
        data|=pSect-&gt;pData[index++]&lt;&lt;8;
        printf( "$%04X", data );
        charpos+=5;
        size-=2;
        break;
      }
    }
  }
}

void  FixRelativeJumps( SSection *pSect )
{
  ULONG  index=0;
  ULONG  size;

  if( pSect-&gt;pData==NULL )
    return;

  size=pSect-&gt;iSize;

  while( size )
  {
    ULONG  data;
    ULONG  code1,
        code2;
    int    found;

    found=0;

    data =pSect-&gt;pData[index++];
    data|=pSect-&gt;pData[index++]&lt;&lt;8;
    data|=pSect-&gt;pData[index++]&lt;&lt;16;
    data|=pSect-&gt;pData[index++]&lt;&lt;24;
    size-=4;

    code1=(data&gt;&gt;29)&amp;0x7;
    code2=(data&gt;&gt;26)&amp;0x7;

    switch( code1 )
    {
      case 0:
        switch( code2 )
        {
          case 1:
          //  REGIMM function
          {
            ULONG  code3,
                code4;

            code3=(data&gt;&gt;19)&amp;0x3;
            code4=(data&gt;&gt;16)&amp;0x7;

            switch( code3 )
            {
              case 0:
                switch( code4 )
                {
                  case 0:
                  case 1:
                  case 2:
                  case 3:
                    found=1;
                    break;
                }
                break;
            }
            break;
          }
          case 4:
          case 5:
          case 6:
          case 7:
            found=1;
            break;
        }
        break;
      case 2:
        switch( code2 )
        {
          case 4:
          case 5:
          case 6:
          case 7:
            found=1;
            break;
        }
        break;
    }

    if( found )
    {
      SSymbol  *pSym;
      int  offset=(SWORD)data;
      offset=(offset&lt;&lt;2)+index;

      pSym=pSect-&gt;pSymbols;
      while( pSym )
      {
        if( pSym-&gt;iOffset==offset )
          break;
        pSym=pSym-&gt;pNext;
      }

      if( pSym==NULL )
      {
        pSym=CreateSymbol( pSect, SYM_LOCAL );
        pSym-&gt;iNumber=iSymbolNumber;
        pSym-&gt;iOffset=offset;
        sprintf( pSym-&gt;sName, "%s_%X", pSect-&gt;sName+1, pSym-&gt;iOffset );
        iSymbolNumber+=1;
      }
    }
  }
}
</pre>

<p>
<br><br><a href="../../emu.htm">返回上一頁</a>
</p>

</div>
</div>
</div>
</body>
</html>
